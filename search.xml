<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>猿人学18题（jsvmp）</title>
    <url>/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/</url>
    <content><![CDATA[<p>猿人学18题链接<br><a href="https://match.yuanrenxue.com/match/18">https://match.yuanrenxue.com/match/18</a><br><span id="more"></span></p>
<ul>
<li><h3 id="1-初步分析，找到加密点"><a href="#1-初步分析，找到加密点" class="headerlink" title="1.初步分析，找到加密点"></a>1.初步分析，找到加密点</h3><blockquote>
<p>要求爬取后几个数据<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/1.png" alt><br> 当点击4，5页面时会出现<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/2.png" alt><br> 此时抓包改ua<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/3.png" alt><br> 会显示如上界面，也就是必须要破解v参数，否则会触发风控系统<br><br> 那么对ajax请求进行栈跟踪，找到加密处<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/4.png" alt><br> 进入getdata，向前面的代码打上断点#<em>也就是xml.send()的前面</em><br> <strong>因为一般来说加密过程在发送数据包的前面</strong><br><br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/5.png" alt><br> 由上图可以看出请求的page只有1，并没有v=后面的加密数据，所以推测加密算法在xml.open()后面，继续步进<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/6.png" alt><br> 可以看到这是混淆代码，所以应该就来到了加密处<font size="1" color="#0000FF">(firefox不知道为什么不能很好的格式化输出，只好用chrome了)</font><br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/7.png" alt><br> 观察传入的四个参数，可以找到有一个是上图所示，不难看出是<strong>AES加密</strong>，且填充方式是<strong>pkcs7</strong><br><br> 那么就可以通过这点进行hook，观察加密参数是什么<br> 保持断点不动，切到console<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/8.png" alt><br> 当输入<code>_[1][0]</code>时可以看到加密相关的参数，我们需要的就是覆盖掉加密函数，这样就能保证每次他进行加密的时候可以知道加密了哪些参数</p>
</blockquote>
</li>
<li><h3 id="2-hook-AES加密，分析加密数据"><a href="#2-hook-AES加密，分析加密数据" class="headerlink" title="2.hook AES加密，分析加密数据"></a>2.hook AES加密，分析加密数据</h3><blockquote>
<p>继续上一步，到console，当我想定义变量的时候，出现以下错误<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/9.png" alt><br> 不知道是什么原因，思考良久以后发现只要在进入混淆代码之前就把变量定义出来就行，如下图<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/10.png" alt><br> 在这时候切到console界面，然后定义变量，到时候就用这个变量<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/11.png" alt><br> 回到调试器，继续步进，回到混淆代码处</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">org_encrypto = _[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>][<span class="string">&#x27;AES&#x27;</span>].<span class="property">encrypt</span>;</span><br><span class="line"></span><br><span class="line">_[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>][<span class="string">&#x27;AES&#x27;</span>].<span class="property">encrypt</span> = <span class="keyword">function</span>(<span class="params">a,b,c,d,e</span>)&#123;</span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">org_encrypto</span>(a,b,c,d,e);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(org_encrypto.<span class="title function_">toString</span>());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/12.png" alt><br> 然后在控制台输入以上代码，进行hook操作<br> 接下来直接继续脚本执行<font size="1"><em>不用f11什么的步进</em></font><br> 当他进行加密操作的时候，会自动跳转到刚刚覆盖的函数encrypt<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/14.png" alt><br> 这时候就可以看到具体加密了什么参数了，到控制台输出一下<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/13.png" alt></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>].<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">stringify</span>(a) <span class="comment">//text</span></span><br><span class="line">_[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>].<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">stringify</span>(b) <span class="comment">//key</span></span><br><span class="line">_[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>].<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">stringify</span>(c.<span class="property">iv</span>) <span class="comment">//iv</span></span><br></pre></td></tr></table></figure>
<p>那么接下来就是分析这些参数具体是怎么生成的了<br> 在调用栈里面回到上一个调用函数<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/15.png" alt><br> 那么在此添加日志断点，可以输出所有经过此函数的变量<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/16.png" alt><br> 这时候把其它断点都去掉，页面刷新一下把hook的函数也去掉，只留下日志断点<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/17.png" alt><br> 可以看到当鼠标移动的时候会在控制台输出以上信息，这时候点击第二页（第三页也行都一样）<br> 可以看到控制台输出了很多其它信息，往上翻找，找到第一次变化的地方<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/18.png" alt><br> <code>1654762249</code>第一个数据，很明显是时间戳<br> 后面跟了一个16，猜测是把时间戳进行16进制转换<br> 用计算器算了一下确实如此，结果为<code>62a1ab09</code>，然后再把结果进行拼接，变为了<code>62a1ab0962a1ab09</code><br> 而另一个数据就是把6个鼠标移动位置进行了拼接，然后前面2|就是当前页码，最后变为<code>2|704m205,702m205,701m205,701d205,701m205,701u205</code><br><br> 那么最后结果就一目了然了，text就是鼠标移动加页面的拼接，另外两个就是iv和key，在这里iv=key<br> 往下翻找到加密后的数据（当然在network那栏也可以找到）也就是v=<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/19.png" alt><br> 用上面的数据进行加密，看看结果是否符合<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/20.png" alt><br> 显然是符合的，有些不一样是因为被url编码了，那么具体加密也了解了，现在开始写python脚本了</p>
</blockquote>
</li>
<li><h3 id="3-脚本实现"><a href="#3-脚本实现" class="headerlink" title="3.脚本实现"></a>3.脚本实现</h3><blockquote>
<p>首先需要获取当前时间戳，并将其转换为16进制，再进行拼接</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AESKEY = <span class="built_in">hex</span>(<span class="built_in">int</span>(time.time())).strip(<span class="string">&#x27;0x&#x27;</span>)+<span class="built_in">hex</span>(<span class="built_in">int</span>(time.time())).strip(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">AESIV = AESKEY</span><br></pre></td></tr></table></figure>
<p>然后是对鼠标位置的拼接，这里直接将上面的鼠标键位复制下来，后与第四页进行拼接<br> <code>text = &#39;4|704m205,702m205,701m205,701d205,701m205,701u205&#39;</code><br>然后在用AES加密</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">AESKEY = <span class="built_in">hex</span>(<span class="built_in">int</span>(time.time())).strip(<span class="string">&#x27;0x&#x27;</span>)+<span class="built_in">hex</span>(<span class="built_in">int</span>(time.time())).strip(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">AESIV = AESKEY</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AESTool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.key = AESKEY.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    self.iv = AESIV.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pkcs7padding</span>(<span class="params">self, text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    明文使用PKCS7填充</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    bs = <span class="number">16</span></span><br><span class="line">    length = <span class="built_in">len</span>(text)</span><br><span class="line">    bytes_length = <span class="built_in">len</span>(text.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    padding_size = length <span class="keyword">if</span> (bytes_length == length) <span class="keyword">else</span> bytes_length</span><br><span class="line">    padding = bs - padding_size % bs</span><br><span class="line">    padding_text = <span class="built_in">chr</span>(padding) * padding</span><br><span class="line">    self.coding = <span class="built_in">chr</span>(padding)</span><br><span class="line">    <span class="keyword">return</span> text + padding_text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encrypt</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    AES加密</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cipher = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">    <span class="comment"># 处理明文</span></span><br><span class="line">    content_padding = self.pkcs7padding(content)</span><br><span class="line">    <span class="comment"># 加密</span></span><br><span class="line">    encrypt_bytes = cipher.encrypt(content_padding.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment"># 重新编码</span></span><br><span class="line">    result = <span class="built_in">str</span>(base64.b64encode(encrypt_bytes), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    AES解密</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cipher = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">    content = base64.b64decode(content)</span><br><span class="line">    text = cipher.decrypt(content).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> self.pkcs7padding(text)</span><br><span class="line">text = <span class="string">&#x27;2|704m205,702m205,701m205,701d205,701m205,701u205&#x27;</span></span><br><span class="line">v = aes_tool.aes_encrypt(text)</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://match.yuanrenxue.com/match/18data?page=2&amp;t=&#123;&#125;&amp;v=&#123;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;yuanrenxue.project&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(url.<span class="built_in">format</span>(timestamp,v),data=data)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>
<p>由于我没有帐号，所以没有session_id，所以无法获取后两页，但是前两页是可以用python获取的，所以逻辑应该是没有问题的<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/21.png" alt></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>爬虫</category>
        <category>js逆向</category>
      </categories>
      <tags>
        <tag>js逆向</tag>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>cve-2021-35042 django sql注入 调试分析</title>
    <url>/2022/06/10/cve-2021-35042/</url>
    <content><![CDATA[<ul>
<li><h2 id="1-如何调试django"><a href="#1-如何调试django" class="headerlink" title="1.如何调试django"></a>1.如何调试django</h2><blockquote>
<p>因为只能找到一些分析文章，但是感觉不透彻，自己干看代码又太难了，google半天找到一个好调试django的方法，结合我自己的一些思路可以调到django源码，而不是单纯调试二次开发的代码，本篇将尽可能从不知道这个函数存在漏洞开始讲解</p>
 <span id="more"></span>
<p>如果想调试二次开发的代码，可以参考以下链接<br> <a href="https://code.visualstudio.com/docs/python/tutorial-django">https://code.visualstudio.com/docs/python/tutorial-django</a><br> 这是vscode的<br><br> 首先需要安装对应版本的django，可以使用以下链接进行搭建博客<br> <a href="https://github.com/H3rmesk1t/Django-SQL-Inject-Env/tree/main/CVE-2021-35042">https://github.com/H3rmesk1t/Django-SQL-Inject-Env/tree/main/CVE-2021-35042</a><br><br> 最好使用python虚拟环境进行搭建，这样就能更方便进行多版本操作<br> 这是官方的搭建python虚拟环境方法<br> <a href="https://docs.python.org/3.8/library/venv.html#creating-virtual-environments">https://docs.python.org/3.8/library/venv.html#creating-virtual-environments</a><br> 我这里就不多介绍了<br><br> 那么搭建完成以后，如何进行调试django<br> StackOverflow上面的方法就是用pdb进行断点调试<br> <code>pdb.set_trace()</code></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vuln</span>(<span class="params">request</span>):</span><br><span class="line">    query = request.GET.get(<span class="string">&#x27;order_by&#x27;</span>, default=<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    pdb.set_trace()</span><br><span class="line">    res = User.objects.order_by(query)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(res.values())</span><br></pre></td></tr></table></figure>
<p>我在order_by前面加上了一个断点，在命令行执行<br> <code>python app.py runserver 127.0.0.1:8000</code><br> 然后访问一下<br> <a href="http://127.0.0.1:8000/vuln/?order_by=id">http://127.0.0.1:8000/vuln/?order_by=id</a><br> <img src="/2022/06/10/cve-2021-35042/1.jpg" alt><br> 可以看到进入了断点<br> 在这里介绍一下几个常用命令</p>
<blockquote>
<p>n: 相当于vscode里面的跨越，也就是执行一条语句，如果是函数就跨越里面<br> s: 就是步进，可以执行到函数里面<br> a: 查看当前变量<br> w: 查看调用堆栈<br> p variable: 查看变量，当然也可以直接输入变量名<br> l: 查看当前上下11行代码<br> c: continue继续执行到下一个断点，如果没有就直接全部执行</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a>这是pdb相关文档<br><br>接下来配合vscode，或者其它编辑器，就可以开始代码审计了</p>
</blockquote>
</li>
<li><h2 id="2-开始审计"><a href="#2-开始审计" class="headerlink" title="2.开始审计"></a>2.开始审计</h2><blockquote>
<p>首先需要知道order<em>by这段源码在哪里，我们可以直接去官网查看数据库相关源码，然后再在本地去寻找<br> <a href="https://docs.djangoproject.com/en/2.0/_modules/django/db/models/query/">https://docs.djangoproject.com/en/2.0/_modules/django/db/models/query/</a><br> 这就是数据库相关源码，在虚拟环境打开这个文件，找到order_by，我这里是`C:\Users\xxxxx\.virtualenvs\django3.2-H6Gg1cu</em>\Lib\site-packages\django\db\models\query.py`<br> 然后下断点，在这里说一下题外话</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vuln</span>(<span class="params">request</span>):</span><br><span class="line">    query = request.GET.get(<span class="string">&#x27;order_by&#x27;</span>, default=<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    res = User.objects.order_by(query)<span class="comment">#这一段并不会执行sql语句</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(res.values())<span class="comment">#他调用了values才会执行</span></span><br></pre></td></tr></table></figure>
<p>继续断点，找到order_by，在这下断点<br> <img src="/2022/06/10/cve-2021-35042/2.jpg" alt><br> 下了断点以后，重启服务器，浏览器访问使用了order_by的那个操作页面,我这里是<br> <a href="http://127.0.0.1:8000/vuln/?order_by=id">http://127.0.0.1:8000/vuln/?order_by=id</a><br> 命令行就会断到这里<br> <img src="/2022/06/10/cve-2021-35042/3.jpg" alt><br> 可以看到确实进来了<br> 输入field_names，可以看到是我们get的参数<br> <img src="/2022/06/10/cve-2021-35042/4.jpg" alt><br> 那么输入s，进入clear_ordering，看看执行了什么<br> <img src="/2022/06/10/cve-2021-35042/5.jpg" alt><br> 可以看到是先执行了这个装饰器函数，因为没有对我们的field_names执行操作，所以就跳过，来到clear_ordering里面<br> <img src="/2022/06/10/cve-2021-35042/6.jpg" alt><br> 只是清空了一些操作，可能是防止上一次order_by的操作对这一次产生影响（如果其它开发人员多次使用了order_by这个函数）但是还是没有对我们的field_names进行过滤什么的，那么就继续，步进到add_ordering里面 <strong>(这里就是关键操作了)</strong><br> 从pdb可以看出，add_ordering在<code>\db\models\sql\query.py</code>这个文件中，用vscode打开</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ordering:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(item, <span class="built_in">str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> item:</span><br><span class="line">        warnings.warn(</span><br><span class="line">            <span class="string">&#x27;Passing column raw column aliases to order_by() is &#x27;</span></span><br><span class="line">            <span class="string">&#x27;deprecated. Wrap %r in a RawSQL expression before &#x27;</span></span><br><span class="line">            <span class="string">&#x27;passing it to order_by().&#x27;</span> % item,</span><br><span class="line">            category=RemovedInDjango40Warning,</span><br><span class="line">            stacklevel=<span class="number">3</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> item.startswith(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">        item = item[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">in</span> self.annotations:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> self.extra <span class="keyword">and</span> item <span class="keyword">in</span> self.extra:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># names_to_path() validates the lookup. A descriptive</span></span><br><span class="line">    <span class="comment"># FieldError will be raise if it&#x27;s not.</span></span><br><span class="line">    self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)</span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(item, <span class="string">&#x27;resolve_expression&#x27;</span>):</span><br><span class="line">    errors.append(item)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">getattr</span>(item, <span class="string">&#x27;contains_aggregate&#x27;</span>, <span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">raise</span> FieldError(</span><br><span class="line">        <span class="string">&#x27;Using an aggregate in order_by() without also including &#x27;</span></span><br><span class="line">        <span class="string">&#x27;it in annotate() is not allowed: %s&#x27;</span> % item</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">if</span> errors:</span><br><span class="line">    <span class="keyword">raise</span> FieldError(<span class="string">&#x27;Invalid order_by arguments: %s&#x27;</span> % errors)</span><br><span class="line"><span class="keyword">if</span> ordering:</span><br><span class="line">    self.order_by += ordering</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.default_ordering = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>可以看到一行注释<br> <code># names_to_path() validates the lookup. A descriptive FieldError will be raise if it&#39;s not.</code><br> 那么这一行大概就是对参数进行过滤的，可以看看里面的重要代码</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path, names_with_path = [], []</span><br><span class="line"><span class="keyword">for</span> pos, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line">cur_names_with_path = (name, [])</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;pk&#x27;</span>:</span><br><span class="line">    name = opts.pk.name</span><br><span class="line"></span><br><span class="line">field = <span class="literal">None</span></span><br><span class="line">filtered_relation = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    field = opts.get_field(name)</span><br><span class="line"><span class="keyword">except</span> FieldDoesNotExist:</span><br></pre></td></tr></table></figure>
<p>注意到这个<code>opts.get_field</code>,是提取表名的一个函数，从缓存中提取，而不是进行sql操作，有兴趣的可以自己进行调试，这里不做过多赘述，总之就是如果不存在这个表就会抛出异常，那么add_ordering里面的<code>self.order_by += ordering</code>就无法执行<br> <img src="/2022/06/10/cve-2021-35042/14.jpg" alt><br> 而order_by在上一个clear_ordering被清空了，<strong>执行sql操作的时候会使用到self.order_by操作</strong><br> 那么就需要绕过这个<code>names_to_path()</code><br><br> 先继续我们的pdb操作<br> 输入ordering<br> <img src="/2022/06/10/cve-2021-35042/7.jpg" alt><br> 可以看到<code>for item in ordering:</code>这个循环就是要遍历我们url里面的get参数，也就是order_by这个参数<br> <a href="http://127.0.0.1:8000/vuln/?order_by=id">http://127.0.0.1:8000/vuln/?order_by=id</a><br> 而这个循环只会循环一次，因为我们元组只有一个<br> 而names_to_path()也在循环里面，而且在最后执行，也就是说如果在中途跳出这个循环，那么也就是跳出了整个循环，也就不会进行检测我们的参数。<br> 看回到这个循环操作代码</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ordering:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, <span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> item:</span><br><span class="line">            warnings.warn(</span><br><span class="line">                <span class="string">&#x27;Passing column raw column aliases to order_by() is &#x27;</span></span><br><span class="line">                <span class="string">&#x27;deprecated. Wrap %r in a RawSQL expression before &#x27;</span></span><br><span class="line">                <span class="string">&#x27;passing it to order_by().&#x27;</span> % item,</span><br><span class="line">                category=RemovedInDjango40Warning,</span><br><span class="line">                stacklevel=<span class="number">3</span>,</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> item.startswith(<span class="string">&#x27;-&#x27;</span>):</span><br><span class="line">            item = item[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> self.annotations:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> self.extra <span class="keyword">and</span> item <span class="keyword">in</span> self.extra:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># names_to_path() validates the lookup. A descriptive</span></span><br><span class="line">        <span class="comment"># FieldError will be raise if it&#x27;s not.</span></span><br><span class="line">        self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)</span><br></pre></td></tr></table></figure>
<p>这几个if里面有continue操作，如果进去了一个，就可以跳出这个循环，而不执行<code>names_to_path</code><br> 首先看第一个</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> item:</span><br><span class="line">    warnings.warn(</span><br><span class="line">        <span class="string">&#x27;Passing column raw column aliases to order_by() is &#x27;</span></span><br><span class="line">        <span class="string">&#x27;deprecated. Wrap %r in a RawSQL expression before &#x27;</span></span><br><span class="line">        <span class="string">&#x27;passing it to order_by().&#x27;</span> % item,</span><br><span class="line">        category=RemovedInDjango40Warning,</span><br><span class="line">        stacklevel=<span class="number">3</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>如果参数中有”.”，就会跳出，这是程序员想着可以使用这种方式<br> table.collection方式用表名和collection，来进行排序，下面这段是思路拓宽，但是没什么用，不想看可以跳过</p>
<blockquote>
<p>那么这时候可能就有人想，能不能访问到其它表中的数据，我们可以试一下，不打断点，直接访问其它表，比如下图这个<br> <img src="/2022/06/10/cve-2021-35042/8.jpg" alt><br> 我们试一下<br> <a href="http://127.0.0.1:8000/vuln/?order_by=django_migrations.name">http://127.0.0.1:8000/vuln/?order_by=django_migrations.name</a><br> <img src="/2022/06/10/cve-2021-35042/9.jpg" alt><br> 可以看到报错了，这时候要找到具体是什么问题<br> 由上面报错信息可以得知<br> <code>File &quot;C:\Users\xxxxx\.virtualenvs\django3.2-H6Gg1cu_\lib\site-packages\django\db\backends\mysql\base.py&quot;, line 75, in execute
 return self.cursor.execute(query, args)</code><br> 在base.py中75行下个断点，看看query具体都是是什么<br> <img src="/2022/06/10/cve-2021-35042/10.jpg" alt><br> 这是第一个query，应该是写死的了，看第二个<br> <img src="/2022/06/10/cve-2021-35042/11.jpg" alt><br> 这就是我们想要的了<br> <code>SELECT `vuln_app_user`.`id`, `vuln_app_user`.`name` FROM `vuln_app_user` ORDER BY (`django_migrations`.name) ASC</code><br> 也就是他前面都是写死的了，order by后面才是我们get参数的，所以不能访问其它表</p>
</blockquote>
<p>那我们回到刚刚循环处<br> 我们可以通过”.”来绕过<br> payload可以写成这样<br> <code>vuln_app_user.id);select updatexml(1, concat(0x7e,(select @@version)),1)%23</code><br> 这个”.”就在vuln_app_user.id这<br><br> 那么有人可能会想，如果把点加到其它地方行不行<br> 那就继续执行，看看到底行不行<br> 前面说过，真正执行sql操作是在<code>res.values()</code>的时候<br> 那就换个地方打断点，把之前的断点撤掉</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vuln</span>(<span class="params">request</span>):</span><br><span class="line">    query = request.GET.get(<span class="string">&#x27;order_by&#x27;</span>, default=<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    res = User.objects.order_by(query)</span><br><span class="line">    pdb.set_trace()</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(res.values())</span><br></pre></td></tr></table></figure>
<p>重新进行访问<br> 因为我们需要看的是self.query.order_by这个参数，所以就在调试的时候尽可能快进到有这个参数的地方<br> <img src="/2022/06/10/cve-2021-35042/12.jpg" alt><br> 最后来到这里<br> field就是query.order_by这个参数，可以用ll命令看多行代码<br> <img src="/2022/06/10/cve-2021-35042/13.jpg" alt></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table, col = col.split(<span class="string">&#x27;.&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">order_by.append((</span><br><span class="line">    OrderBy(</span><br><span class="line">        RawSQL(<span class="string">&#x27;%s.%s&#x27;</span> % (self.quote_name_unless_alias(table), col), []),</span><br><span class="line">        descending=descending</span><br><span class="line">    ), <span class="literal">False</span>))</span><br></pre></td></tr></table></figure>
<p>他会将点的位置进行切分，然后再给table加上反引号再去拼接，也就是如果我们随便加个点<br> 比如<br> <code>id.);select updatexml(1, concat(0x7e,(select @@version)),1)%23</code><br> 那他就会变为</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`id`.);select updatexml(1, concat(0x7e,(select @@version)),1)%23</span><br></pre></td></tr></table></figure>
<p>那样就会直接报错，而不是报后面updatexml的报错注入<br> 当然也应该有其它绕过方式，比如多加个反引号之类进行闭合，但是我也不太懂，</p>
</blockquote>
</li>
<li><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><blockquote>
<p>主要问题就是可以绕过names_to_path的检测，然后把恶意代码直接拼接进去，但是可能需要知道数据表名称才能注入，我也不太清楚如何能不靠数据表进行注入，希望有大佬懂得话可以评论留言</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sql注入</tag>
        <tag>代码审计</tag>
        <tag>django</tag>
      </tags>
  </entry>
</search>
