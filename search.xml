<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>猿人学18题（jsvmp）</title>
    <url>/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/</url>
    <content><![CDATA[<p>猿人学18题链接<br><a href="https://match.yuanrenxue.com/match/18">https://match.yuanrenxue.com/match/18</a></p>
<ul>
<li><h3 id="1-初步分析，找到加密点"><a href="#1-初步分析，找到加密点" class="headerlink" title="1.初步分析，找到加密点"></a>1.初步分析，找到加密点</h3><blockquote>
<p>要求爬取后几个数据<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/1.png" alt><br> 当点击4，5页面时会出现<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/2.png" alt><br> 此时抓包改ua<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/3.png" alt><br> 会显示如上界面，也就是必须要破解v参数，否则会触发风控系统<br><br> 那么对ajax请求进行栈跟踪，找到加密处<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/4.png" alt><br> 进入getdata，向前面的代码打上断点#<em>也就是xml.send()的前面</em><br> <strong>因为一般来说加密过程在发送数据包的前面</strong><br><br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/5.png" alt><br> 由上图可以看出请求的page只有1，并没有v=后面的加密数据，所以推测加密算法在xml.open()后面，继续步进<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/6.png" alt><br> 可以看到这是混淆代码，所以应该就来到了加密处<font size="1" color="#0000FF">(firefox不知道为什么不能很好的格式化输出，只好用chrome了)</font><br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/7.png" alt><br> 观察传入的四个参数，可以找到有一个是上图所示，不难看出是<strong>AES加密</strong>，且填充方式是<strong>pkcs7</strong><br><br> 那么就可以通过这点进行hook，观察加密参数是什么<br> 保持断点不动，切到console<br> <img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/8.png" alt><br> 当输入<code>_[1][0]</code>时可以看到加密相关的参数，我们需要的就是覆盖掉加密函数，这样就能保证每次他进行加密的时候可以知道加密了哪些参数</p>
<ul>
<li><h3 id="2-hook-AES加密，分析加密数据"><a href="#2-hook-AES加密，分析加密数据" class="headerlink" title="2.hook AES加密，分析加密数据"></a>2.hook AES加密，分析加密数据</h3>继续上一步，到console，当我想定义变量的时候，出现以下错误<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/9.png" alt><br>不知道是什么原因，思考良久以后发现只要在进入混淆代码之前就把变量定义出来就行，如下图<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/10.png" alt><br>在这时候切到console界面，然后定义变量，到时候就用这个变量<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/11.png" alt><br>回到调试器，继续步进，回到混淆代码处<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">org_encrypto = _[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>][<span class="string">&#x27;AES&#x27;</span>].<span class="property">encrypt</span>;</span><br><span class="line"></span><br><span class="line">_[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>][<span class="string">&#x27;AES&#x27;</span>].<span class="property">encrypt</span> = <span class="keyword">function</span>(<span class="params">a,b,c,d,e</span>)&#123;</span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">org_encrypto</span>(a,b,c,d,e);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(org_encrypto.<span class="title function_">toString</span>());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/12.png" alt><br>然后在控制台输入以上代码，进行hook操作<br>接下来直接继续脚本执行<font size="1"><em>不用f11什么的步进</em></font><br>当他进行加密操作的时候，会自动跳转到刚刚覆盖的函数encrypt<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/14.png" alt><br>这时候就可以看到具体加密了什么参数了，到控制台输出一下<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/13.png" alt><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>].<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">stringify</span>(a) <span class="comment">//text</span></span><br><span class="line">_[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>].<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">stringify</span>(b) <span class="comment">//key</span></span><br><span class="line">_[<span class="number">1</span>][<span class="number">0</span>][<span class="string">&#x27;CryptoJS&#x27;</span>].<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">stringify</span>(c.<span class="property">iv</span>) <span class="comment">//iv</span></span><br></pre></td></tr></table></figure>
那么接下来就是分析这些参数具体是怎么生成的了<br>在调用栈里面回到上一个调用函数<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/15.png" alt><br>那么在此添加日志断点，可以输出所有经过此函数的变量<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/16.png" alt><br>这时候把其它断点都去掉，页面刷新一下把hook的函数也去掉，只留下日志断点<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/17.png" alt><br>可以看到当鼠标移动的时候会在控制台输出以上信息，这时候点击第二页（第三页也行都一样）<br>可以看到控制台输出了很多其它信息，往上翻找，找到第一次变化的地方<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/18.png" alt><br><code>1654762249</code>第一个数据，很明显是时间戳<br>后面跟了一个16，猜测是把时间戳进行16进制转换<br>用计算器算了一下确实如此，结果为<code>62a1ab09</code>，然后再把结果进行拼接，变为了<code>62a1ab0962a1ab09</code><br>而另一个数据就是把6个鼠标移动位置进行了拼接，然后前面2|就是当前页码，最后变为<code>2|704m205,702m205,701m205,701d205,701m205,701u205</code><br><br>那么最后结果就一目了然了，text就是鼠标移动加页面的拼接，另外两个就是iv和key，在这里iv=key<br>往下翻找到加密后的数据（当然在network那栏也可以找到）也就是v=<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/19.png" alt><br>用上面的数据进行加密，看看结果是否符合<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/20.png" alt><br>显然是符合的，有些不一样是因为被url编码了，那么具体加密也了解了，现在开始写python脚本了</li>
<li><h3 id="3-脚本实现"><a href="#3-脚本实现" class="headerlink" title="3.脚本实现"></a>3.脚本实现</h3>首先需要获取当前时间戳，并将其转换为16进制，再进行拼接<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AESKEY = <span class="built_in">hex</span>(<span class="built_in">int</span>(time.time())).strip(<span class="string">&#x27;0x&#x27;</span>)+<span class="built_in">hex</span>(<span class="built_in">int</span>(time.time())).strip(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">AESIV = AESKEY</span><br></pre></td></tr></table></figure>
然后是对鼠标位置的拼接，这里直接将上面的鼠标键位复制下来，后与第四页进行拼接<br><code>text = &#39;4|704m205,702m205,701m205,701d205,701m205,701u205&#39;</code><br>然后在用AES加密<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">AESKEY = <span class="built_in">hex</span>(<span class="built_in">int</span>(time.time())).strip(<span class="string">&#x27;0x&#x27;</span>)+<span class="built_in">hex</span>(<span class="built_in">int</span>(time.time())).strip(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">AESIV = AESKEY</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AESTool</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.key = AESKEY.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    self.iv = AESIV.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pkcs7padding</span>(<span class="params">self, text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    明文使用PKCS7填充</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    bs = <span class="number">16</span></span><br><span class="line">    length = <span class="built_in">len</span>(text)</span><br><span class="line">    bytes_length = <span class="built_in">len</span>(text.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    padding_size = length <span class="keyword">if</span> (bytes_length == length) <span class="keyword">else</span> bytes_length</span><br><span class="line">    padding = bs - padding_size % bs</span><br><span class="line">    padding_text = <span class="built_in">chr</span>(padding) * padding</span><br><span class="line">    self.coding = <span class="built_in">chr</span>(padding)</span><br><span class="line">    <span class="keyword">return</span> text + padding_text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encrypt</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    AES加密</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cipher = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">    <span class="comment"># 处理明文</span></span><br><span class="line">    content_padding = self.pkcs7padding(content)</span><br><span class="line">    <span class="comment"># 加密</span></span><br><span class="line">    encrypt_bytes = cipher.encrypt(content_padding.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment"># 重新编码</span></span><br><span class="line">    result = <span class="built_in">str</span>(base64.b64encode(encrypt_bytes), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    AES解密</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cipher = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">    content = base64.b64decode(content)</span><br><span class="line">    text = cipher.decrypt(content).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> self.pkcs7padding(text)</span><br><span class="line">text = <span class="string">&#x27;2|704m205,702m205,701m205,701d205,701m205,701u205&#x27;</span></span><br><span class="line">v = aes_tool.aes_encrypt(text)</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://match.yuanrenxue.com/match/18data?page=2&amp;t=&#123;&#125;&amp;v=&#123;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;yuanrenxue.project&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(url.<span class="built_in">format</span>(timestamp,v),data=data)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>
由于我没有帐号，所以没有session_id，所以无法获取后两页，但是前两页是可以用python获取的，所以逻辑应该是没有问题的<br><img src="/2022/06/09/%E7%8C%BF%E4%BA%BA%E5%AD%A618%E9%A2%98/21.png" alt></li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>爬虫</category>
        <category>js逆向</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>js逆向</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
